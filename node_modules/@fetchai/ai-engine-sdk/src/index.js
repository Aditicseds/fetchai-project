"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AiEngine = exports.Session = void 0;
const uuid_1 = require("uuid");
const api_1 = require("./types/api");
const models_1 = require("@fetchai/ai-engine-sdk/types/models");
__exportStar(require("./types/messages"), exports);
const defaultApiBaseUrl = "https://agentverse.ai";
async function makeApiRequest(apiBaseUrl, apiKey, method, endpoint, payload) {
    const body = payload ? JSON.stringify(payload) : null;
    const response = await fetch(`${apiBaseUrl}${endpoint}`, {
        method: method,
        headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${apiKey}`,
        },
        body,
    });
    if (!response.ok) {
        throw new Error(`Request failed with status ${response.status} to ${endpoint}`);
    }
    return await response.json();
}
class Session {
    constructor(apiBaseUrl, apiKey, sessionId, functionGroup) {
        this._messages = [];
        this._messageIds = new Set();
        this._apiBaseUrl = apiBaseUrl;
        this._apiKey = apiKey;
        this.sessionId = sessionId;
        this.functionGroup = functionGroup;
    }
    async _submitMessage(payload) {
        await makeApiRequest(this._apiBaseUrl, this._apiKey, "POST", `/v1beta1/engine/chat/sessions/${this.sessionId}/submit`, {
            payload,
        });
    }
    async start(objective, context) {
        await this._submitMessage({
            type: "start",
            session_id: this.sessionId,
            bucket_id: this.functionGroup,
            message_id: (0, uuid_1.v4)().toString().toLowerCase(),
            objective,
            context: context ?? "",
        });
    }
    async submitTaskSelection(selection, options) {
        await this._submitMessage({
            type: "user_json",
            session_id: this.sessionId,
            message_id: (0, uuid_1.v4)().toString().toLowerCase(),
            referral_id: selection.id,
            user_json: {
                type: "task_list",
                selection: options.map((o) => o.key),
            },
        });
    }
    async submitResponse(query, response) {
        await this._submitMessage({
            type: "user_message",
            session_id: this.sessionId,
            message_id: (0, uuid_1.v4)().toString().toLowerCase(),
            referral_id: query.id,
            user_message: response,
        });
    }
    async submitConfirmation(confirmation) {
        await this._submitMessage({
            type: "user_message",
            session_id: this.sessionId,
            message_id: (0, uuid_1.v4)().toString().toLowerCase(),
            referral_id: confirmation.id,
            user_message: "confirm",
        });
    }
    async rejectConfirmation(confirmation, reason) {
        await this._submitMessage({
            type: "user_message",
            session_id: this.sessionId,
            message_id: (0, uuid_1.v4)().toString().toLowerCase(),
            referral_id: confirmation.id,
            user_message: reason,
        });
    }
    async getMessages() {
        let queryParams = "";
        if (this._messages.length > 0) {
            queryParams = `?last_message_id=${this._messages[this._messages.length - 1].message_id}`;
        }
        const response = await makeApiRequest(this._apiBaseUrl, this._apiKey, "GET", `/v1beta1/engine/chat/sessions/${this.sessionId}/new-messages${queryParams}`, null);
        const newMessages = [];
        for (const item of response.agent_response) {
            const message = JSON.parse(item);
            // it is possible that a message may be delivered multiple times, therefore we need to filter out duplicates
            if (this._messageIds.has(message.message_id)) {
                continue;
            }
            if ((0, api_1.isApiAgentJsonMessage)(message)) {
                if ((0, api_1.isApiTaskList)(message.agent_json)) {
                    newMessages.push({
                        id: message.message_id,
                        type: "task_selection",
                        timestamp: new Date(message.timestamp),
                        text: message.agent_json.text,
                        options: message.agent_json.options.map((o) => {
                            return { key: o.key, title: o.value };
                        }),
                    });
                }
                else if ((0, api_1.isApiContextJson)(message.agent_json)) {
                    newMessages.push({
                        id: message.message_id,
                        type: "confirmation",
                        text: message.agent_json.text,
                        timestamp: new Date(message.timestamp),
                        model: message.agent_json.context_json.digest,
                        payload: message.agent_json.context_json.args,
                    });
                }
                else {
                    console.error("UNKNOWN-JSON:", message);
                }
            }
            else if ((0, api_1.isApiAgentInfoMessage)(message)) {
                newMessages.push({
                    id: message.message_id,
                    type: "ai-engine",
                    timestamp: new Date(message.timestamp),
                    text: message.agent_info,
                });
            }
            else if ((0, api_1.isApiAgentMessageMessage)(message)) {
                newMessages.push({
                    id: message.message_id,
                    type: "agent",
                    timestamp: new Date(message.timestamp),
                    text: message.agent_message,
                });
            }
            else if ((0, api_1.isApiStopMessage)(message)) {
                newMessages.push({
                    id: message.message_id,
                    timestamp: new Date(message.timestamp),
                    type: "stop",
                });
            }
            else {
                console.error("UNKNOWN:", message);
            }
            // store the message (if we have not already seen it)
            if (!this._messageIds.has(message.message_id)) {
                this._messages.push(message);
                this._messageIds.add(message.message_id);
            }
        }
        return newMessages;
    }
    async delete() {
        await makeApiRequest(this._apiBaseUrl, this._apiKey, "DELETE", `/v1beta1/engine/chat/sessions/${this.sessionId}`, null);
    }
}
exports.Session = Session;
class AiEngine {
    constructor(apiKey, options) {
        this._apiBaseUrl = options?.apiBaseUrl ?? defaultApiBaseUrl;
        this._apiKey = apiKey;
    }
    async getFunctionGroups() {
        const [publicGroups, privateGroups] = await Promise.all([
            this.getPublicFunctionGroups(),
            this.getPrivateFunctionGroups(),
        ]);
        return [...privateGroups, ...publicGroups];
    }
    async getPublicFunctionGroups() {
        return await makeApiRequest(this._apiBaseUrl, this._apiKey, "GET", "/v1beta1/function-groups/public/", null);
    }
    async getPrivateFunctionGroups() {
        return await makeApiRequest(this._apiBaseUrl, this._apiKey, "GET", "/v1beta1/function-groups/", null);
    }
    async getCredits() {
        const r = await makeApiRequest(this._apiBaseUrl, this._apiKey, "GET", "/v1beta1/engine/credit/info", null);
        return {
            totalCredits: r.total_credit,
            usedCredits: r.used_credit,
            availableCredits: r.available_credit,
        };
    }
    async getModels() {
        const pendingCredits = [];
        const models = [];
        for (const modelId of models_1.DefaultModelIds) {
            pendingCredits.push(this.getModelCredits(modelId));
            models.push({
                id: modelId,
                name: (0, models_1.getModelName)(modelId),
                credits: 0,
            });
        }
        const credits = await Promise.all(pendingCredits);
        // sanity check
        if (credits.length !== models.length) {
            throw new Error("Credit count mismatch");
        }
        for (let i = 0; i < models.length; i++) {
            models[i].credits = credits[i];
        }
        return models;
    }
    async getModelCredits(model) {
        const modelId = (0, models_1.getModelId)(model);
        const r = await makeApiRequest(this._apiBaseUrl, this._apiKey, "GET", `/v1beta1/engine/credit/remaining_tokens?models=${modelId}`, null);
        return r.model_tokens[modelId] ?? 0;
    }
    async createSession(functionGroup, opts) {
        const response = await makeApiRequest(this._apiBaseUrl, this._apiKey, "POST", "/v1beta1/engine/chat/sessions", {
            email: opts?.email ?? "",
            functionGroup,
            preferencesEnabled: false,
            requestModel: opts?.model ?? models_1.DefaultModelId,
        });
        return new Session(this._apiBaseUrl, this._apiKey, response.session_id, functionGroup);
    }
}
exports.AiEngine = AiEngine;
